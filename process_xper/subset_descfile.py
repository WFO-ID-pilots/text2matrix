"""
This script takes a subset of the WFO descfile generated by dwca2csv.py to include only the species
in the provided list.
"""

import argparse
import pandas as pd
import re

def spname_identity(binom:str, test:str) -> bool:
    """
    Check whether test is a species/subspecies represented by binom, taking hybrids and variants/subspecies into account
    This function will return True if test is a subspecies within binom.

    Parameters:
        binom (str): Latin binomial or a hybrid species name
        test (str): Loosely-structured test string to determine identity with binom

    Returns:
        is_represented (bool): Whether test is represented by binom
    """

    # Capture epithets from binom string
    binom_parts:list[str] = re.findall(r'×?([A-Za-z]+)×?', binom)
    
    # Capture epithets from test string
    test_parts:list[str] = re.findall(r'×?([A-Za-z]+)×?', test)

    # Check if the epithets in the binom string match those in the test string
    is_represented:bool = False not in [
        binom_parts[i:i+1] == test_parts[i:i+1]
        for i in range(0, len(binom_parts))
    ]

    return is_represented

def main():
    # Create the parser
    parser = argparse.ArgumentParser(description = 'Subset a descfile based on a list of species names')

    # Basic I/O arguments
    parser.add_argument('descfile', type = str, help = 'Species description tsv file')
    parser.add_argument('taxafile', type = str, help = 'Species name tsv file')
    parser.add_argument('spplist', type = str, help = 'Species list')
    parser.add_argument('--spplistsep', type = str, default = ',', help = 'Separator character to use for the species list')
    parser.add_argument('outfile', type = str, help = 'Output file for the subsetted species descriptions')
    parser.add_argument('--taxaout', required = False, type = str, help = 'Optional output file for the subsetted taxa file')
    
    # Parse the arguments
    args = parser.parse_args()

    # ===== Load input files =====
    desc_df = pd.read_csv(args.descfile, sep='\t') # Dataframe of the species descriptions
    taxa_df = pd.read_csv(args.taxafile, sep='\t') # Dataframe of the taxa list
    spp_list:list[str] = [] # List of species to extract
    with open(args.spplist, 'r') as fp:
        spp_list = fp.read().split(args.spplistsep)

    # ===== Filter for given species =====

    # List of species names in taxa_df and corresponding ids as tuple
    taxa_df_spp = [
        (id, sci_name) for id, sci_name
        in zip(taxa_df.index, taxa_df['scientificName'].tolist())
    ]

    # List of ids of species names in the taxa_df which are found in spp_list
    found_spp_ids:list[int] = []
    for listed_sp in spp_list:
        match_list = list(filter(lambda sp: spname_identity(listed_sp, sp[1]), taxa_df_spp))
        found_spp_ids.extend(
            [match_list[0][0]] if len(match_list) > 0 else []
        )
    
    # Subset taxa_df
    taxa_df_sub = taxa_df.iloc[found_spp_ids]

    # Get list of WFO IDs for the given species
    coreid_list:list[str] = taxa_df_sub['coreid'].tolist()

    # ===== Subset descfile based on coreids =====

    # Subset desc_df
    desc_df_sub = desc_df[desc_df['coreid'].isin(coreid_list)]

    # ===== Write results =====

    # Write subsetted desc_df to file
    desc_df_sub.to_csv(args.outfile, sep='\t', index=False)
    
    # Select taxa for which an entry exists in desc_df
    taxa_df_sub = taxa_df_sub[taxa_df_sub['coreid'].isin(desc_df_sub['coreid'])]

    # Write subsetted taxa_df to file if specified
    if args.taxaout != None:
        taxa_df_sub.to_csv(args.taxaout, sep='\t', index=False)
        

if __name__ == '__main__':
    main()